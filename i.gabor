#!/usr/bin/env python
#%Module
#% description: Creates Gabor filter bank for an n-dimensional image
#% overwrite: yes
#% keyword: raster
#% keyword: filter
#%End

# FLAGS
#%flag
#% key: c
#% description: Make combined averaged raster
#%end
#%flag
#% key: i
#% description: Use imaginary number output
#%end
#%flag
#% key: q
#% description: Create binary quantified output
#%end

# OPTIONS
#%option
#% key: input
#% type: string
#% required: yes
#% description: Input
#%end
#%option
#% key: output
#% type: string
#% required: yes
#% description: Output
#%end
#%option
#% key: size
#% type: integer
#% required: no
#% description: Size of the window
#% answer: 11
#%end
#%option
#% key: orientation
#% type: integer
#% required: no
#% multiple: yes
#% description: List of orientations in degrees
#% answer: 0, 45, 90, 135
#%end
#%option
#% key: wavelength
#% type: double
#% required: no
#% description: Wavelengh of sinusoidal wave
#% answer: 3
#%end
#%option
#% key: offset
#% type: integer
#% required: no
#% description: Phase offset from the center
#% answer: 0
#%end
#%option
#% key: aspect
#% type: double
#% required: no
#% description: Aspect ratio, specifies ellipticity
#% answer: 0.5
#%end
#%option
#% key: threshold
#% type: integer
#% required: no
#% description: Threshold to extract
#% answer: 0
#%end
#%option
#% key: type
#% type: string
#% required: no
#% description: Threshold to extract
#% answer: "real"
#%end

import grass.script as grass
from grass.script import array as garray
import numpy as np


def deg_to_radians(deg):
    return deg * np.pi / 180


def radians_to_deg(rad):
    return rad * 180 / np.pi


def get_center(shape):
    return shape[0] // 2, shape[1] // 2


def cart_to_logpol(x, y, xc, yc):
    p = np.log(((x - xc) ** 2 + (y - yc) ** 2) ** (1 / 2))
    theta = np.arctan2(y - yc, x - yc)
    return p, theta


def gabor_filter(win_size, stddev, orientation, wavelength, offset, aspect):

    # Get half size of full kernel
    xy = win_size // 2

    # Sigma in x direction
    sigma_x = stddev
    # Specify ellipticity of gaussian curve
    sigma_y = float(stddev) / aspect
    stddev = stddev

    # Create meshgrid for vectorized NumPy functions
    (y, x) = np.meshgrid(np.arange(-xy, xy + 1), np.arange(-xy, xy + 1))

    # Convert degrees to radians
    radian = deg_to_radians(orientation)
    # Rotation
    x_radian = x * np.cos(radian) + y * np.sin(radian)
    y_radian = -x * np.sin(radian) + y * np.cos(radian)

    # Create gaussian with specified orientation
    gaussian = np.exp(
        -0.5 * (x_radian ** 2 / sigma_x ** 2 + y_radian ** 2 / sigma_y ** 2)
    )

    # Create oscilating sin wave
    waveform = np.cos(2 * np.pi / wavelength * x_radian + offset)
    gabor = gaussian * waveform
    return gabor


def gabor2d(win_size, orientation=0, wavelength=5, aspect=0.5, offset=0, ntype='real'):
    # Get window size +/- around origin
    xy = win_size // 2

    # Check to make sure wave length is not greater than half the window size
    if wavelength >= xy:
        raise Exception("Need smaller wavelength")

    orientation = deg_to_radians(orientation)
    stddev = xy // wavelength
    max = xy
    min = -xy
    (y, x) = np.meshgrid(np.arange(min, max + 1), np.arange(min, max + 1))
    xr = x * np.cos(orientation) + y * np.sin(orientation)
    yr = -x * np.sin(orientation) + y * np.cos(orientation)

    gaussian = np.exp(-((xr ** 2 + aspect ** 2 * yr ** 2) / (2 * stddev**2)))
    if ntype == 'imag':
        sf = np.sin(2 * np.pi * xr / wavelength + offset)
    else:
        sf = np.cos(2 * np.pi * xr / wavelength + offset)
    return gaussian * sf


def gabor_convolve(inarr, kern, thresh, quantify=0):
    con = fftconvolve(inarr, kern, mode="same")
    if not thresh:
        return con
    per = np.percentile(con, thresh)
    if quantify > 0:
        return np.where(con >= per, quantify, 0)
    return np.where(con >= per, con, 0)


if __name__ == "__main__":
    # Lazy import for scipy.signal.fftconvolve
    try:
        from scipy.signal import fftconvolve
    except ImportError:
        grass.fatal("Cannot import fftconvolve from scipy")



    # Parse options and flags
    options, flags = grass.parser()


    input = options.get("input")
    output = options.get("output")

    win_size = int(options.get("size"))
    orientation = [int(o) for o in options.get("orientation").split(",")]
    wavelength = [float(f) for f in options.get('wavelength').split(",")]
    offset = float(options.get("offset"))
    aspect = float(options.get("aspect"))
    if flags.get('i'):
        ntype = "imag"
    else:
        ntype = "real"
    threshold = int(options.get("threshold"))

    if flags.get('q'):
        q = [2 ** i for i in range(len(orientation))]
    else:
        q = 0


    filters = {}
    for deg in orientation:
        for freq in wavelength:
            name = f"{win_size}_{deg}_{freq}_{offset}_{aspect}"
            filters[name] = gabor2d(win_size, deg, freq, aspect, offset, ntype)


    inarr = garray.array()
    inarr.read(input)
    if flags.get('c'):
        convolved = []
        if type(q) == list:
            for i in range(len(filters.keys())):
                name = list(filters.keys())[i]
                convolved.append(gabor_convolve(inarr, filters.get(name), threshold, q[i]))
        else:
            for name in filters.keys():
                convolved.append(gabor_convolve(inarr, filters.get(name), threshold))
        outarr = garray.array()
        out = np.sum(convolved, axis=0)
        outarr[...] = out
        outarr.write(output)
    else:
        for name in filters.keys():
            outarr = garray.array()
            outarr[...] = gabor_convolve(inarr, filters.get(name), threshold)
            outarr.write(f"{name.replace('.', '')}_{output}")

